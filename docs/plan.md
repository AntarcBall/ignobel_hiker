
1. 등산 경로 로컬 3차원 직교(예: ENU / East-North-Up) 좌표계로 근사, 즉 그냥 x,y,z처럼 이용!
2. 모든 hiker에 대해 그 차이 벡터를 구하기
3. 그 변위 벡터를 사이 시간으로 나눠서 순간 속도 벡터
4. 그것들의 속력 계산


6. 2025-10-07T22:12:12Z 이후 끝날 때까지의 데이터 포인트만 측정한다! (config_3d.py 도 실행하면서, 무효한 것들 끝난 뒤에를 시작 포인트로 지정!)

---
    
 2: 토투로시티 (Tortuosity)**
    4. **총 이동 거리 (Path Length)**: 위에서 계산한 `Total Distance`입니다.
    5. **시작점-끝점 직선 거리 (Straight-line Distance)**: 등산 시작점(`(lat_0, lon_0)`)과 끝점(`(lat_{N-1}, lon_{N-1})`) 사이의 직선 거리를 계산합니다.
    6. **토투로시티 계산**: 총 이동 거리를 시작점-끝점 직선 거리로 나눕니다.  
        $$ \text{Tortuosity} = \frac{\text{Total Path Length}}{\text{Straight-line Distance from Start to End}} $$
- **단위**: 누적 절대 회전각은 라디안/미터 (rad/m), 토투로시티는 단위 없음 (비율).
### 1. 총 이동 거리 (total_distance)

- **목표**: 등산 경로의 전체 길이를 측정합니다.
- **개념**: 등산 시작부터 끝까지, 모든 작은 이동 거리들을 합한 것입니다.
- **계산 단계**:
    1. **각 구간 거리 계산**: 인접한 두 GPS 표본 `(i-1)`과 `i` 사이의 거리 `d_i`를 계산합니다.
        - `d_i = distance((lat_{i-1}, lon_{i-1}), (lat_i, lon_i))`
        - (예: `i=1`일 때는 `(lat_0, lon_0)`와 `(lat_1, lon_1)` 사이의 거리)
    2. **모든 구간 거리 합산**: 계산된 모든 `d_i` 값들을 처음부터 끝까지 더합니다.  
        $$ \text{Total Distance} = \sum_{i=1}^{N-1} d_i $$
- **단위**: 미터 (m)
- **해석**: 이 값이 클수록 더 긴 거리를 이동했다는 뜻입니다.

### 4. 정지(멈춤) 관련 (stop_count, total_stop_time)

- **목표**: 등산 중 얼마나 자주, 얼마나 오랫동안 멈춰 있었는지 측정합니다.
- **개념**: 사람이 잠시 쉬거나 경치를 구경하기 위해 멈춘 시간을 파악합니다.
- **계산 단계**:
    1. **정지 판단 기준**:
        - 속도가 `0.2 m/s` 미만 (거의 움직이지 않음)
        - 이 상태가 `10초` 이상 지속될 때
        - (이 값들은 제안된 것이며, 필요에 따라 조절할 수 있습니다.)
    2. **정지 구간 찾기**: GPS 데이터를 시간 순서대로 보면서, 위 기준을 만족하는 구간을 찾습니다.
    3. **정지 시간 총합 (total_stop_time)**: 찾은 모든 정지 구간의 지속 시간을 합산합니다.
        - `Total Stop Time = sum(duration_of_each_stop)`
    4. **정지 빈도 (stop_count)**: 찾은 정지 구간의 총 개수를 셉니다.
    5. **정지 비율 (stop_time_fraction)**: 전체 등산 시간 대비 정지 시간의 비율을 계산합니다.
        - `Stop Time Fraction = Total Stop Time / Total Time`
- **단위**: `total_stop_time`은 초 (s), `stop_count`는 횟수 (단위 없음), `stop_time_fraction`은 비율 (단위 없음).
- **해석**: `total_stop_time`이 길고 `stop_count`가 많으면 자주 쉬거나 오랫동안 쉰다는 뜻입니다. 적절한 휴식은 '사람다운' 등산의 중요한 요소일 수 있습니다.

### 6. 리더 지수 (leader_score)

- **목표**: 여러 사람이 함께 등산할 때, 특정 사람이 얼마나 자주 선두에 섰는지 측정합니다.
- **개념**: 그룹 내에서 누가 길을 이끌었는지 파악하는 지표입니다. (이 지표는 **그룹 데이터**가 있을 때만 사용할 수 있습니다.)
- **계산 단계**:
    1. **그룹 멤버 위치 동기화**: 모든 그룹 멤버의 GPS 데이터를 같은 시간 기준으로 정렬합니다.
    2. **각 시점의 선두 판단**: 1. 선형 근사 보간(즉, 2차원g(t)데이터라면 (1,0)에서 (4,9)데이터밖에 없는데 t=2데이터를 원하는 경우 일직선 이동으로 간주해서 (2,3)을 추측한다.  )해서 t=k,2k,3k... 별로의 hiker별 위치 좌표를 추출 2.각 시간포인트때, 다음 시간때의 3명 hiker의 위치 중심에 대한 거리를 현재 hiker위치별로 계산해서 순위를 매기는걸 계속 반복
    3. **선두 유지 시간 비율 (lead_fraction)**: 해당 사람이 선두였던 총 시간을 전체 등산 시간으로 나눕니다.
        - `Lead Fraction = (해당 사람이 선두였던 시간) / (전체 시간)`
    4. **평균 선두 마진 (average_lead_margin)**: 해당 사람이 선두였을 때, 뒤따르는 사람들과의 평균 거리 차이를 계산합니다.
    5. **리더 변경 횟수 (lead_switch_count)**: 선두가 다른 사람으로 바뀐 횟수를 셉니다.
- **단위**: `lead_fraction`은 비율 (단위 없음), `average_lead_margin`은 미터 (m), `lead_switch_count`는 횟수 (단위 없음).
- **해석**: `lead_fraction`이 높으면 선두를 많이 유지했다는 뜻입니다. 하지만 '사람다운' 등산에서는 지나치게 앞서가는 것이 항상 좋다고만은 볼 수 없습니다.

### 12. 종합 점수 (Weighted sum or multivariate)

- **목표**: 위에서 계산한 여러 개별 특성(서브스코어)들을 하나로 합쳐서 최종적인 '등산 스타일 점수'를 만듭니다.
- **개념**: 여러 가지 요소를 종합적으로 고려하여 한 사람의 등산 능력을 평가합니다.
- **계산 단계**:
    1. **서브스코어 정규화 (Normalization)**: 각 서브스코어(예: `total_distance`, `pace_variability` 등)는 단위와 범위가 다릅니다. 이를 0부터 100 사이의 값으로 통일시켜 비교 가능하게 만듭니다.
        - **Min-Max 정규화**: `s_k' = 100 * (s_k - min_k) / (max_k - min_k)`
            - `s_k`: 원래 서브스코어 값
            - `min_k`: 해당 서브스코어의 최소값
            - `max_k`: 해당 서브스코어의 최대값
            - (이 방법은 비교 대상 그룹의 최소/최대값을 알아야 합니다.)
        
    2. **가중치 (Weight) 부여**: 각 서브스코어가 최종 점수에 얼마나 중요하게 반영될지 결정하는 `w_k` 값을 정합니다. 모든 가중치의 합은 1이 되어야 합니다.
        - `sum(w_k) = 1`
        - (예: '꾸준한 페이스'가 중요하다고 생각하면 `steady_pace_score`에 높은 가중치를 줍니다.),단 현재는 모든 서브스코어를 1대1대1로 고려한다.
    3. **가중합 계산**: 정규화된 서브스코어에 가중치를 곱하여 모두 더합니다.  
    